\documentclass{report}
\input{../../library/preamble}
\input{../../library/style}
\addbibresource{../../library/bibliography.bib}

\title{EPO-2: Mid-term Design Report - Draadloze Communicatie met ZigBee Module}
\author{Tijmen Witte}

\begin{document}

TO_DO

computer robot uart wireless zigbee
verbinding tussen computer en robot

eisen verderop

command structuur 

test



\chapter{Draadloze Communicatie met ZigBee Module}

Een van de opdrachten van het project is om de robot te begeleiden via een C-programma. Het is de bedoeling dat we door middel van het draadloze communicatie systeem van ZigBee de robot laten communiceren met de computer. Dit wordt gedaan door één XBee-module aan te sluiten op een computer en deze te laten communiceren met een andere XBee-module die  gemonteerd zit op het robot utility board.
\newline

\noindent XBee modules zijn in feite niks anders dan digitale ontvang/zend systemen die op een 2.4 Ghz bandbreedte werken. Ze hebben een bereik van circa 30 tot 60 meter, waardoor ze makkelijk met andere apparaten kunnen communiceren die ook op een 2.4Ghz bandbreedte zitten. Daarnaast wordt de XBee module gevoed door een 3.3V spanning, verder kan het aantal signaalwisselingen per seconde nog worden ingesteld. Hier gaan we later  verder op in.
\newline



\section{Eisen}

Voordat de XBee modules met elkaar kunnen communiceren moeten ze eerst met elkaar worden geconfigureerd, zodat ze dezelfde unieke instellingen hebben. Als dit niet wordt gedaan is het mogelijk dat andere XBee modules gaan communiceren met andere modules terwijl dit niet de bedoeling is.
\newline
De XBee modules bevatten een aantal instelpunten die ervoor zorgen dat er onderscheidt kan worden gemaakt tussen de verschillende XBee modules. De belangrijkste hiervan zullen verder uitgelicht worden;
\newline

\textbf{Channel settings;}
\newline
De XBee modules kunnen op zestien verschillende frequentiebreedtes werken, van 11(0x0B) tot 26 (0x1A). Als er onderscheid moet worden gemaakt tussen XBee modules in de omgeving is het handig om deze op een andere frequentiebreedte te zetten.
\newline

\textbf{Pan-Id;}
\newline
Als er meerdere XBee modules op dezelfde frequentiebreedte zitten kan er nog steeds onderscheid worden gemaakt tussen de XBee modules door middel van \textit{Pan-ID}. Deze bestaat uit een 16-bits nummer. Door op beide XBee modules de \textit{Pan-ID}  met hetzelfde nummer in te stellen, kan er alleen nog maar gecommuniceerd worden met de XBee modules die hetzelfde \textit{Pan-ID} hebben.
\newline

\textbf{My-ID;}
\newline
Het is mogelijk dat er meerdere XBee modules hetzelfde\textit{ Pan-Id} hebben. Er moet daarom ook nog onderscheid kunnen worden gemaakt tussen de XBee modules met hetzelfde \textit{Pan-Id}. Dit kan worden gedaan door \textit{My-Id} van de ene XBee modules, in te stellen in \textit{DL} van de andere XBee module, als je dit ook voor de andere XBee module doet, kan er alleen nog maar gecommuniceerd worden tussen deze XBees.


\section{Ontwerp}
Voordat de XBee modules met elkaar kunnen communiceren moet er eerst een VHDL-code ontworpen worden voor de XBee module op de robot en een C-code voor de XBee module die met de computer is verbonden.
\textbf{[afbeelding 3.1 van tutorial]}.
\newline

De VHDL-code bestaat uit een Top-entity en Sub-entities;
\newline

\textbf{Top-entity}.
\newline
We willen ervoor zorgen dat de ontvangen bits worden getoond op de LEDs en de bits die verzonden moeten worden door de robot, verzonden worden door middel van de switches. De bits die worden verzonden en ontvangen worden gebufferd in een 8-bit register en met behulp van flag flip-flops wordt de status van de 8-bit register bijgehouden. Het verzenden van de bits begint als de write-data '1' is. De ontvangen bits worden verwijderd als read-data '1' is. Verder is er nog een 50MHz klok aanwezig.
\newline

\textbf{Sub-entities;}
\newline
Er zijn vier sub-entities, namelijk;
\begin{itemize}
\item  \textbf{Baud rate generator;}
\newline
De baud rate generator zorgt ervoor dat er nauwkeurig wordt bijgehouden welke bits er binnenkomen.

\item \textbf{UART receiver}
\newline 
De UART receiver bevat een FSM die bestaat uit vier statussen namelijk; idle, start, data en stop.
Hoe de FSM werkt, is afhankelijk van de kloksignalen die deze binnenkrijgt van de baud rate generator en de status van het 'rx' signaal.
De FSM begint in de idle status als 'rx' signaal 1 heeft. Als rx vervolgens signaal 0 krijgt, gaat de FSM in de start status en begint het de pulsen te tellen. Er zijn twee soorten tellers, \textit{n} en \textit{s}. De eerste houdt het aantal pulsen bij, de tweede het ontvangen aantal data bits. De ontvangen bits worden verplaatst naar een 8-bit register. Als alles is afgerond, wordt het ontvangen bit gekopieerd naar de buffer register, waar op hetzelfde moment de flag flip-flop wordt ingesteld.
 
 \item \textbf{UART transmitter}
 \newline
 De UART transmitter is een register die data bits op een bepaald tempo verplaatst. Dit tempo wordt beïnvloed door de pulsen van de baud rate generator. Als het overdracht proces van één data status is voltooid, wordt de flag flip-flop hierdoor gereset
 
 \item \textbf{Buffer register met flag flip-flops}
 \newline
 De buffer register zorgt voor een link tussen het UART sub-systeem en het hoofdsysteem. Een flag flip-flop houdt bij of de buffer register, vol of leeg is.
\newline
Als de UART receiver de ontvangen bit doorgeeft, geeft de flag flip-flop weer dat de buffer register gelezen is door het hoofdsysteem en dat die nu opnieuw ingesteld kan worden.
\newline
Als voor de UART transmitter de flag flip-flop aangeeft dat de buffer register de juiste data bevat om verzonden te worden, dan zal de UART transmitter op de actieve status van de flip-flop reageren en beginnen met verzenden. De data van de buffer register wordt gekopieerd naar de UART transmitter en als deze vervolgens klaar is met het proces zal de flag flip-flop gereset worden, waarna er weer nieuwe data kan worden ontvangen 
 
\end{itemize}
De C-code die voor de communicatie geschreven moest worden, moet er voor zorgen dat er vanuit de C-code gecommuniceerd kan worden met de VHDL-code op de robot.
\newline
Voor de instellingen van de XBee module konden we zelf waarden voor de verschillende instelpunten kiezen.

\section{Implementatie}

Voor de VHDL-code, de C-code en de instellingen van de XBee module zie bijlage;

\section{Test}

Door te kijken of we bits van de computer naar de robot konden sturen en deze vervolgens in de juiste led volgorde op de robot verschenen en door daarna bits te sturen van de robot naar de computer en te kijken of deze met de juiste ASCII-karakters overeen kwam, is gebleken dat de draadloze communicatie tussen de XBee module van de computer en de XBee module van de robot goed werkte.

\section{Discussie}

Het draadloos communiceren van de XBee's werkte zeer goed. 
Wat wellicht een probleem kan zijn, is dat toevallig mensen dezelfde instellingen hebben gekozen waardoor er tussen verschillende groepen gecommuniceerd wordt, wat zeker niet de bedoeling is. Dit is echter bij ons niet het geval geweest.

\end{document}